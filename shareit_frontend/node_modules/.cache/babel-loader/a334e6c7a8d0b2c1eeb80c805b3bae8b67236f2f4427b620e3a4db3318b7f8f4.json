{"ast":null,"code":"import { invariant } from '../../../utils/errors.mjs';\nimport { isCSSVariableToken } from './is-css-variable.mjs';\n\n/**\r\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\r\n *\r\n * ```\r\n * `var(--foo, #fff)` => [`--foo`, '#fff']\r\n * ```\r\n *\r\n * @param current\r\n */\nconst splitCSSVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n  const match = splitCSSVariableRegex.exec(current);\n  if (!match) return [,];\n  const [, token, fallback] = match;\n  return [token, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n  const [token, fallback] = parseCSSVariable(current);\n  // No CSS variable detected\n  if (!token) return;\n  // Attempt to read this CSS variable off the element\n  const resolved = window.getComputedStyle(element).getPropertyValue(token);\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariableToken(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\r\n * Resolve CSS variables from\r\n *\r\n * @internal\r\n */\nfunction resolveCSSVariables(visualElement, {\n  ...target\n}, transitionEnd) {\n  const element = visualElement.current;\n  if (!(element instanceof Element)) return {\n    target,\n    transitionEnd\n  };\n  // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n  if (transitionEnd) {\n    transitionEnd = {\n      ...transitionEnd\n    };\n  }\n  // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n  visualElement.values.forEach(value => {\n    const current = value.get();\n    if (!isCSSVariableToken(current)) return;\n    const resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  });\n  // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n  for (const key in target) {\n    const current = target[key];\n    if (!isCSSVariableToken(current)) continue;\n    const resolved = getVariableValue(current, element);\n    if (!resolved) continue;\n    // Clone target if it hasn't already been\n    target[key] = resolved;\n    if (!transitionEnd) transitionEnd = {};\n    // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n    if (transitionEnd[key] === undefined) {\n      transitionEnd[key] = current;\n    }\n  }\n  return {\n    target,\n    transitionEnd\n  };\n}\nexport { parseCSSVariable, resolveCSSVariables };","map":{"version":3,"names":["invariant","isCSSVariableToken","splitCSSVariableRegex","parseCSSVariable","current","match","exec","token","fallback","maxDepth","getVariableValue","element","depth","resolved","window","getComputedStyle","getPropertyValue","trim","resolveCSSVariables","visualElement","target","transitionEnd","Element","values","forEach","value","get","set","key","undefined"],"sources":["C:/Users/k546k/Desktop/멋쟁이사자/쉐어잇/shareit_frontend/node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs"],"sourcesContent":["import { invariant } from '../../../utils/errors.mjs';\r\nimport { isCSSVariableToken } from './is-css-variable.mjs';\r\n\r\n/**\r\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\r\n *\r\n * ```\r\n * `var(--foo, #fff)` => [`--foo`, '#fff']\r\n * ```\r\n *\r\n * @param current\r\n */\r\nconst splitCSSVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\r\nfunction parseCSSVariable(current) {\r\n    const match = splitCSSVariableRegex.exec(current);\r\n    if (!match)\r\n        return [,];\r\n    const [, token, fallback] = match;\r\n    return [token, fallback];\r\n}\r\nconst maxDepth = 4;\r\nfunction getVariableValue(current, element, depth = 1) {\r\n    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\r\n    const [token, fallback] = parseCSSVariable(current);\r\n    // No CSS variable detected\r\n    if (!token)\r\n        return;\r\n    // Attempt to read this CSS variable off the element\r\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\r\n    if (resolved) {\r\n        return resolved.trim();\r\n    }\r\n    else if (isCSSVariableToken(fallback)) {\r\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\r\n        return getVariableValue(fallback, element, depth + 1);\r\n    }\r\n    else {\r\n        return fallback;\r\n    }\r\n}\r\n/**\r\n * Resolve CSS variables from\r\n *\r\n * @internal\r\n */\r\nfunction resolveCSSVariables(visualElement, { ...target }, transitionEnd) {\r\n    const element = visualElement.current;\r\n    if (!(element instanceof Element))\r\n        return { target, transitionEnd };\r\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\r\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\r\n    if (transitionEnd) {\r\n        transitionEnd = { ...transitionEnd };\r\n    }\r\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\r\n    visualElement.values.forEach((value) => {\r\n        const current = value.get();\r\n        if (!isCSSVariableToken(current))\r\n            return;\r\n        const resolved = getVariableValue(current, element);\r\n        if (resolved)\r\n            value.set(resolved);\r\n    });\r\n    // Cycle through every target property and resolve CSS variables. Currently\r\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\r\n    for (const key in target) {\r\n        const current = target[key];\r\n        if (!isCSSVariableToken(current))\r\n            continue;\r\n        const resolved = getVariableValue(current, element);\r\n        if (!resolved)\r\n            continue;\r\n        // Clone target if it hasn't already been\r\n        target[key] = resolved;\r\n        if (!transitionEnd)\r\n            transitionEnd = {};\r\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\r\n        // CSS variable. This will ensure that after the animation the component will reflect\r\n        // changes in the value of the CSS variable.\r\n        if (transitionEnd[key] === undefined) {\r\n            transitionEnd[key] = current;\r\n        }\r\n    }\r\n    return { target, transitionEnd };\r\n}\r\n\r\nexport { parseCSSVariable, resolveCSSVariables };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}