{"ast":null,"code":"import _objectSpread from \"C:/Users/k546k/Desktop/\\uBA4B\\uC7C1\\uC774\\uC0AC\\uC790/\\uC250\\uC5B4\\uC787/shareit_frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/k546k/Desktop/\\uBA4B\\uC7C1\\uC774\\uC0AC\\uC790/\\uC250\\uC5B4\\uC787/shareit_frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"root\"];\n/**\r\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\r\n * element, so even though these handlers might all be triggered by different\r\n * observers, we can keep them in the same map.\r\n */\nvar observerCallbacks = new WeakMap();\n/**\r\n * Multiple observers can be created for multiple element/document roots. Each with\r\n * different settings. So here we store dictionaries of observers to each root,\r\n * using serialised settings (threshold/margin) as lookup keys.\r\n */\nvar observers = new WeakMap();\nvar fireObserverCallback = function fireObserverCallback(entry) {\n  var callback = observerCallbacks.get(entry.target);\n  callback && callback(entry);\n};\nvar fireAllObserverCallbacks = function fireAllObserverCallbacks(entries) {\n  entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_ref) {\n  var root = _ref.root,\n    options = _objectWithoutProperties(_ref, _excluded);\n  var lookupRoot = root || document;\n  /**\r\n   * If we don't have an observer lookup map for this root, create one.\r\n   */\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n  var rootObservers = observers.get(lookupRoot);\n  var key = JSON.stringify(options);\n  /**\r\n   * If we don't have an observer for this combination of root and settings,\r\n   * create one.\r\n   */\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, _objectSpread({\n      root: root\n    }, options));\n  }\n  return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n  var rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return function () {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\nexport { observeIntersection };","map":{"version":3,"names":["observerCallbacks","WeakMap","observers","fireObserverCallback","entry","callback","get","target","fireAllObserverCallbacks","entries","forEach","initIntersectionObserver","_ref","root","options","_objectWithoutProperties","_excluded","lookupRoot","document","has","set","rootObservers","key","JSON","stringify","IntersectionObserver","_objectSpread","observeIntersection","element","rootInteresectionObserver","observe","delete","unobserve"],"sources":["C:/Users/k546k/Desktop/멋쟁이사자/쉐어잇/shareit_frontend/node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs"],"sourcesContent":["/**\r\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\r\n * element, so even though these handlers might all be triggered by different\r\n * observers, we can keep them in the same map.\r\n */\r\nconst observerCallbacks = new WeakMap();\r\n/**\r\n * Multiple observers can be created for multiple element/document roots. Each with\r\n * different settings. So here we store dictionaries of observers to each root,\r\n * using serialised settings (threshold/margin) as lookup keys.\r\n */\r\nconst observers = new WeakMap();\r\nconst fireObserverCallback = (entry) => {\r\n    const callback = observerCallbacks.get(entry.target);\r\n    callback && callback(entry);\r\n};\r\nconst fireAllObserverCallbacks = (entries) => {\r\n    entries.forEach(fireObserverCallback);\r\n};\r\nfunction initIntersectionObserver({ root, ...options }) {\r\n    const lookupRoot = root || document;\r\n    /**\r\n     * If we don't have an observer lookup map for this root, create one.\r\n     */\r\n    if (!observers.has(lookupRoot)) {\r\n        observers.set(lookupRoot, {});\r\n    }\r\n    const rootObservers = observers.get(lookupRoot);\r\n    const key = JSON.stringify(options);\r\n    /**\r\n     * If we don't have an observer for this combination of root and settings,\r\n     * create one.\r\n     */\r\n    if (!rootObservers[key]) {\r\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\r\n    }\r\n    return rootObservers[key];\r\n}\r\nfunction observeIntersection(element, options, callback) {\r\n    const rootInteresectionObserver = initIntersectionObserver(options);\r\n    observerCallbacks.set(element, callback);\r\n    rootInteresectionObserver.observe(element);\r\n    return () => {\r\n        observerCallbacks.delete(element);\r\n        rootInteresectionObserver.unobserve(element);\r\n    };\r\n}\r\n\r\nexport { observeIntersection };\r\n"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA,IAAMA,iBAAiB,GAAG,IAAIC,OAAO,CAAC,CAAC;AACvC;AACA;AACA;AACA;AACA;AACA,IAAMC,SAAS,GAAG,IAAID,OAAO,CAAC,CAAC;AAC/B,IAAME,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAIC,KAAK,EAAK;EACpC,IAAMC,QAAQ,GAAGL,iBAAiB,CAACM,GAAG,CAACF,KAAK,CAACG,MAAM,CAAC;EACpDF,QAAQ,IAAIA,QAAQ,CAACD,KAAK,CAAC;AAC/B,CAAC;AACD,IAAMI,wBAAwB,GAAG,SAA3BA,wBAAwBA,CAAIC,OAAO,EAAK;EAC1CA,OAAO,CAACC,OAAO,CAACP,oBAAoB,CAAC;AACzC,CAAC;AACD,SAASQ,wBAAwBA,CAAAC,IAAA,EAAuB;EAAA,IAApBC,IAAI,GAAAD,IAAA,CAAJC,IAAI;IAAKC,OAAO,GAAAC,wBAAA,CAAAH,IAAA,EAAAI,SAAA;EAChD,IAAMC,UAAU,GAAGJ,IAAI,IAAIK,QAAQ;EACnC;AACJ;AACA;EACI,IAAI,CAAChB,SAAS,CAACiB,GAAG,CAACF,UAAU,CAAC,EAAE;IAC5Bf,SAAS,CAACkB,GAAG,CAACH,UAAU,EAAE,CAAC,CAAC,CAAC;EACjC;EACA,IAAMI,aAAa,GAAGnB,SAAS,CAACI,GAAG,CAACW,UAAU,CAAC;EAC/C,IAAMK,GAAG,GAAGC,IAAI,CAACC,SAAS,CAACV,OAAO,CAAC;EACnC;AACJ;AACA;AACA;EACI,IAAI,CAACO,aAAa,CAACC,GAAG,CAAC,EAAE;IACrBD,aAAa,CAACC,GAAG,CAAC,GAAG,IAAIG,oBAAoB,CAACjB,wBAAwB,EAAAkB,aAAA;MAAIb,IAAI,EAAJA;IAAI,GAAKC,OAAO,CAAE,CAAC;EACjG;EACA,OAAOO,aAAa,CAACC,GAAG,CAAC;AAC7B;AACA,SAASK,mBAAmBA,CAACC,OAAO,EAAEd,OAAO,EAAET,QAAQ,EAAE;EACrD,IAAMwB,yBAAyB,GAAGlB,wBAAwB,CAACG,OAAO,CAAC;EACnEd,iBAAiB,CAACoB,GAAG,CAACQ,OAAO,EAAEvB,QAAQ,CAAC;EACxCwB,yBAAyB,CAACC,OAAO,CAACF,OAAO,CAAC;EAC1C,OAAO,YAAM;IACT5B,iBAAiB,CAAC+B,MAAM,CAACH,OAAO,CAAC;IACjCC,yBAAyB,CAACG,SAAS,CAACJ,OAAO,CAAC;EAChD,CAAC;AACL;AAEA,SAASD,mBAAmB"},"metadata":{},"sourceType":"module","externalDependencies":[]}