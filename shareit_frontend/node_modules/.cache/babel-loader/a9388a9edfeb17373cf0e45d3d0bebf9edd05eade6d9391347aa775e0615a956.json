{"ast":null,"code":"function createRenderStep(runNextFrame) {\n  /**\r\n   * We create and reuse two arrays, one to queue jobs for the current frame\r\n   * and one for the next. We reuse to avoid triggering GC after x frames.\r\n   */\n  var toRun = [];\n  var toRunNextFrame = [];\n  /**\r\n   *\r\n   */\n  var numToRun = 0;\n  /**\r\n   * Track whether we're currently processing jobs in this step. This way\r\n   * we can decide whether to schedule new jobs for this frame or next.\r\n   */\n  var isProcessing = false;\n  var flushNextFrame = false;\n  /**\r\n   * A set of processes which were marked keepAlive when scheduled.\r\n   */\n  var toKeepAlive = new WeakSet();\n  var step = {\n    /**\r\n     * Schedule a process to run on the next frame.\r\n     */\n    schedule: function schedule(callback) {\n      var keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var addToCurrentFrame = immediate && isProcessing;\n      var buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n      if (keepAlive) toKeepAlive.add(callback);\n      // If the buffer doesn't already contain this callback, add it\n      if (buffer.indexOf(callback) === -1) {\n        buffer.push(callback);\n        // If we're adding it to the currently running buffer, update its measured size\n        if (addToCurrentFrame && isProcessing) numToRun = toRun.length;\n      }\n      return callback;\n    },\n    /**\r\n     * Cancel the provided callback from running on the next frame.\r\n     */\n    cancel: function cancel(callback) {\n      var index = toRunNextFrame.indexOf(callback);\n      if (index !== -1) toRunNextFrame.splice(index, 1);\n      toKeepAlive.delete(callback);\n    },\n    /**\r\n     * Execute all schedule callbacks.\r\n     */\n    process: function process(frameData) {\n      /**\r\n       * If we're already processing we've probably been triggered by a flushSync\r\n       * inside an existing process. Instead of executing, mark flushNextFrame\r\n       * as true and ensure we flush the following frame at the end of this one.\r\n       */\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n      isProcessing = true;\n      // Clear the next frame list\n      var _ref = [toRunNextFrame, toRun];\n      toRun = _ref[0];\n      toRunNextFrame = _ref[1];\n      toRunNextFrame.length = 0;\n      // Execute this frame\n      numToRun = toRun.length;\n      if (numToRun) {\n        for (var i = 0; i < numToRun; i++) {\n          var callback = toRun[i];\n          callback(frameData);\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n          }\n        }\n      }\n      isProcessing = false;\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\nexport { createRenderStep };","map":{"version":3,"names":["createRenderStep","runNextFrame","toRun","toRunNextFrame","numToRun","isProcessing","flushNextFrame","toKeepAlive","WeakSet","step","schedule","callback","keepAlive","arguments","length","undefined","immediate","addToCurrentFrame","buffer","add","indexOf","push","cancel","index","splice","delete","process","frameData","_ref","i","has"],"sources":["C:/Users/k546k/Desktop/멋쟁이사자/쉐어잇/shareit_frontend/node_modules/framer-motion/dist/es/frameloop/render-step.mjs"],"sourcesContent":["function createRenderStep(runNextFrame) {\r\n    /**\r\n     * We create and reuse two arrays, one to queue jobs for the current frame\r\n     * and one for the next. We reuse to avoid triggering GC after x frames.\r\n     */\r\n    let toRun = [];\r\n    let toRunNextFrame = [];\r\n    /**\r\n     *\r\n     */\r\n    let numToRun = 0;\r\n    /**\r\n     * Track whether we're currently processing jobs in this step. This way\r\n     * we can decide whether to schedule new jobs for this frame or next.\r\n     */\r\n    let isProcessing = false;\r\n    let flushNextFrame = false;\r\n    /**\r\n     * A set of processes which were marked keepAlive when scheduled.\r\n     */\r\n    const toKeepAlive = new WeakSet();\r\n    const step = {\r\n        /**\r\n         * Schedule a process to run on the next frame.\r\n         */\r\n        schedule: (callback, keepAlive = false, immediate = false) => {\r\n            const addToCurrentFrame = immediate && isProcessing;\r\n            const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\r\n            if (keepAlive)\r\n                toKeepAlive.add(callback);\r\n            // If the buffer doesn't already contain this callback, add it\r\n            if (buffer.indexOf(callback) === -1) {\r\n                buffer.push(callback);\r\n                // If we're adding it to the currently running buffer, update its measured size\r\n                if (addToCurrentFrame && isProcessing)\r\n                    numToRun = toRun.length;\r\n            }\r\n            return callback;\r\n        },\r\n        /**\r\n         * Cancel the provided callback from running on the next frame.\r\n         */\r\n        cancel: (callback) => {\r\n            const index = toRunNextFrame.indexOf(callback);\r\n            if (index !== -1)\r\n                toRunNextFrame.splice(index, 1);\r\n            toKeepAlive.delete(callback);\r\n        },\r\n        /**\r\n         * Execute all schedule callbacks.\r\n         */\r\n        process: (frameData) => {\r\n            /**\r\n             * If we're already processing we've probably been triggered by a flushSync\r\n             * inside an existing process. Instead of executing, mark flushNextFrame\r\n             * as true and ensure we flush the following frame at the end of this one.\r\n             */\r\n            if (isProcessing) {\r\n                flushNextFrame = true;\r\n                return;\r\n            }\r\n            isProcessing = true;\r\n            [toRun, toRunNextFrame] = [toRunNextFrame, toRun];\r\n            // Clear the next frame list\r\n            toRunNextFrame.length = 0;\r\n            // Execute this frame\r\n            numToRun = toRun.length;\r\n            if (numToRun) {\r\n                for (let i = 0; i < numToRun; i++) {\r\n                    const callback = toRun[i];\r\n                    callback(frameData);\r\n                    if (toKeepAlive.has(callback)) {\r\n                        step.schedule(callback);\r\n                        runNextFrame();\r\n                    }\r\n                }\r\n            }\r\n            isProcessing = false;\r\n            if (flushNextFrame) {\r\n                flushNextFrame = false;\r\n                step.process(frameData);\r\n            }\r\n        },\r\n    };\r\n    return step;\r\n}\r\n\r\nexport { createRenderStep };\r\n"],"mappings":"AAAA,SAASA,gBAAgBA,CAACC,YAAY,EAAE;EACpC;AACJ;AACA;AACA;EACI,IAAIC,KAAK,GAAG,EAAE;EACd,IAAIC,cAAc,GAAG,EAAE;EACvB;AACJ;AACA;EACI,IAAIC,QAAQ,GAAG,CAAC;EAChB;AACJ;AACA;AACA;EACI,IAAIC,YAAY,GAAG,KAAK;EACxB,IAAIC,cAAc,GAAG,KAAK;EAC1B;AACJ;AACA;EACI,IAAMC,WAAW,GAAG,IAAIC,OAAO,CAAC,CAAC;EACjC,IAAMC,IAAI,GAAG;IACT;AACR;AACA;IACQC,QAAQ,EAAE,SAAAA,SAACC,QAAQ,EAA2C;MAAA,IAAzCC,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;MAAA,IAAEG,SAAS,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;MACrD,IAAMI,iBAAiB,GAAGD,SAAS,IAAIX,YAAY;MACnD,IAAMa,MAAM,GAAGD,iBAAiB,GAAGf,KAAK,GAAGC,cAAc;MACzD,IAAIS,SAAS,EACTL,WAAW,CAACY,GAAG,CAACR,QAAQ,CAAC;MAC7B;MACA,IAAIO,MAAM,CAACE,OAAO,CAACT,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;QACjCO,MAAM,CAACG,IAAI,CAACV,QAAQ,CAAC;QACrB;QACA,IAAIM,iBAAiB,IAAIZ,YAAY,EACjCD,QAAQ,GAAGF,KAAK,CAACY,MAAM;MAC/B;MACA,OAAOH,QAAQ;IACnB,CAAC;IACD;AACR;AACA;IACQW,MAAM,EAAE,SAAAA,OAACX,QAAQ,EAAK;MAClB,IAAMY,KAAK,GAAGpB,cAAc,CAACiB,OAAO,CAACT,QAAQ,CAAC;MAC9C,IAAIY,KAAK,KAAK,CAAC,CAAC,EACZpB,cAAc,CAACqB,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;MACnChB,WAAW,CAACkB,MAAM,CAACd,QAAQ,CAAC;IAChC,CAAC;IACD;AACR;AACA;IACQe,OAAO,EAAE,SAAAA,QAACC,SAAS,EAAK;MACpB;AACZ;AACA;AACA;AACA;MACY,IAAItB,YAAY,EAAE;QACdC,cAAc,GAAG,IAAI;QACrB;MACJ;MACAD,YAAY,GAAG,IAAI;MAEnB;MAAA,IAAAuB,IAAA,GAD0B,CAACzB,cAAc,EAAED,KAAK,CAAC;MAAhDA,KAAK,GAAA0B,IAAA;MAAEzB,cAAc,GAAAyB,IAAA;MAEtBzB,cAAc,CAACW,MAAM,GAAG,CAAC;MACzB;MACAV,QAAQ,GAAGF,KAAK,CAACY,MAAM;MACvB,IAAIV,QAAQ,EAAE;QACV,KAAK,IAAIyB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,QAAQ,EAAEyB,CAAC,EAAE,EAAE;UAC/B,IAAMlB,QAAQ,GAAGT,KAAK,CAAC2B,CAAC,CAAC;UACzBlB,QAAQ,CAACgB,SAAS,CAAC;UACnB,IAAIpB,WAAW,CAACuB,GAAG,CAACnB,QAAQ,CAAC,EAAE;YAC3BF,IAAI,CAACC,QAAQ,CAACC,QAAQ,CAAC;YACvBV,YAAY,CAAC,CAAC;UAClB;QACJ;MACJ;MACAI,YAAY,GAAG,KAAK;MACpB,IAAIC,cAAc,EAAE;QAChBA,cAAc,GAAG,KAAK;QACtBG,IAAI,CAACiB,OAAO,CAACC,SAAS,CAAC;MAC3B;IACJ;EACJ,CAAC;EACD,OAAOlB,IAAI;AACf;AAEA,SAAST,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}