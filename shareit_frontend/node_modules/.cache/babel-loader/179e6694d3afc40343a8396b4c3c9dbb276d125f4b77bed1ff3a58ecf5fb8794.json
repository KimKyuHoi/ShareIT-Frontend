{"ast":null,"code":"import _slicedToArray from \"C:/Users/k546k/Desktop/\\uBA4B\\uC7C1\\uC774\\uC0AC\\uC790/\\uC250\\uC5B4\\uC787/shareit_frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { mix } from '../../utils/mix.mjs';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\nfunction scalePoint(point, scale, originPoint) {\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\r\n * Applies a translate/scale delta to a point\r\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\nfunction applyAxisDelta(axis) {\n  var translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var originPoint = arguments.length > 3 ? arguments[3] : undefined;\n  var boxScale = arguments.length > 4 ? arguments[4] : undefined;\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\r\n * Applies a translate/scale delta to a box\r\n */\nfunction applyBoxDelta(box, _ref) {\n  var x = _ref.x,\n    y = _ref.y;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\nfunction applyTreeDeltas(box, treeScale, treePath) {\n  var isSharedTransition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var treeLength = treePath.length;\n  if (!treeLength) return;\n  // Reset the treeScale\n  treeScale.x = treeScale.y = 1;\n  var node;\n  var delta;\n  for (var i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.projectionDelta;\n    /**\r\n     * TODO: Prefer to remove this, but currently we have motion components with\r\n     * display: contents in Framer.\r\n     */\n    var instance = node.instance;\n    if (instance && instance.style && instance.style.display === \"contents\") {\n      continue;\n    }\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, {\n        x: -node.scroll.offset.x,\n        y: -node.scroll.offset.y\n      });\n    }\n    if (delta) {\n      // Incoporate each ancestor's scale into a culmulative treeScale for this component\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale;\n      // Apply each ancestor's calculated delta into this component's recorded layout box\n      applyBoxDelta(box, delta);\n    }\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n  /**\r\n   * Snap tree scale back to 1 if it's within a non-perceivable threshold.\r\n   * This will help reduce useless scales getting rendered.\r\n   */\n  treeScale.x = snapToDefault(treeScale.x);\n  treeScale.y = snapToDefault(treeScale.y);\n}\nfunction snapToDefault(scale) {\n  if (Number.isInteger(scale)) return scale;\n  return scale > 1.0000000000001 || scale < 0.999999999999 ? scale : 1;\n}\nfunction translateAxis(axis, distance) {\n  axis.min = axis.min + distance;\n  axis.max = axis.max + distance;\n}\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\nfunction transformAxis(axis, transforms, _ref2) {\n  var _ref3 = _slicedToArray(_ref2, 3),\n    key = _ref3[0],\n    scaleKey = _ref3[1],\n    originKey = _ref3[2];\n  var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n  var originPoint = mix(axis.min, axis.max, axisOrigin);\n  // Apply the axis delta to the final axis\n  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\r\n * The names of the motion values we want to apply as translation, scale and origin.\r\n */\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform, xKeys);\n  transformAxis(box.y, transform, yKeys);\n}\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };","map":{"version":3,"names":["mix","hasTransform","scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","arguments","length","min","max","applyBoxDelta","box","_ref","x","y","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","node","delta","i","projectionDelta","instance","style","display","options","layoutScroll","scroll","root","transformBox","offset","latestValues","snapToDefault","Number","isInteger","translateAxis","distance","transformAxis","transforms","_ref2","_ref3","_slicedToArray","key","scaleKey","originKey","axisOrigin","xKeys","yKeys","transform"],"sources":["C:/Users/k546k/Desktop/멋쟁이사자/쉐어잇/shareit_frontend/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs"],"sourcesContent":["import { mix } from '../../utils/mix.mjs';\r\nimport { hasTransform } from '../utils/has-transform.mjs';\r\n\r\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\r\nfunction scalePoint(point, scale, originPoint) {\r\n    const distanceFromOrigin = point - originPoint;\r\n    const scaled = scale * distanceFromOrigin;\r\n    return originPoint + scaled;\r\n}\r\n/**\r\n * Applies a translate/scale delta to a point\r\n */\r\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, boxScale, originPoint);\r\n    }\r\n    return scalePoint(point, scale, originPoint) + translate;\r\n}\r\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\r\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\r\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Applies a translate/scale delta to a box\r\n */\r\nfunction applyBoxDelta(box, { x, y }) {\r\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\r\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\r\n}\r\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\r\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\r\n    const treeLength = treePath.length;\r\n    if (!treeLength)\r\n        return;\r\n    // Reset the treeScale\r\n    treeScale.x = treeScale.y = 1;\r\n    let node;\r\n    let delta;\r\n    for (let i = 0; i < treeLength; i++) {\r\n        node = treePath[i];\r\n        delta = node.projectionDelta;\r\n        /**\r\n         * TODO: Prefer to remove this, but currently we have motion components with\r\n         * display: contents in Framer.\r\n         */\r\n        const instance = node.instance;\r\n        if (instance &&\r\n            instance.style &&\r\n            instance.style.display === \"contents\") {\r\n            continue;\r\n        }\r\n        if (isSharedTransition &&\r\n            node.options.layoutScroll &&\r\n            node.scroll &&\r\n            node !== node.root) {\r\n            transformBox(box, {\r\n                x: -node.scroll.offset.x,\r\n                y: -node.scroll.offset.y,\r\n            });\r\n        }\r\n        if (delta) {\r\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\r\n            treeScale.x *= delta.x.scale;\r\n            treeScale.y *= delta.y.scale;\r\n            // Apply each ancestor's calculated delta into this component's recorded layout box\r\n            applyBoxDelta(box, delta);\r\n        }\r\n        if (isSharedTransition && hasTransform(node.latestValues)) {\r\n            transformBox(box, node.latestValues);\r\n        }\r\n    }\r\n    /**\r\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\r\n     * This will help reduce useless scales getting rendered.\r\n     */\r\n    treeScale.x = snapToDefault(treeScale.x);\r\n    treeScale.y = snapToDefault(treeScale.y);\r\n}\r\nfunction snapToDefault(scale) {\r\n    if (Number.isInteger(scale))\r\n        return scale;\r\n    return scale > 1.0000000000001 || scale < 0.999999999999 ? scale : 1;\r\n}\r\nfunction translateAxis(axis, distance) {\r\n    axis.min = axis.min + distance;\r\n    axis.max = axis.max + distance;\r\n}\r\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\r\nfunction transformAxis(axis, transforms, [key, scaleKey, originKey]) {\r\n    const axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\r\n    const originPoint = mix(axis.min, axis.max, axisOrigin);\r\n    // Apply the axis delta to the final axis\r\n    applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\r\n}\r\n/**\r\n * The names of the motion values we want to apply as translation, scale and origin.\r\n */\r\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\r\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\r\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\r\nfunction transformBox(box, transform) {\r\n    transformAxis(box.x, transform, xKeys);\r\n    transformAxis(box.y, transform, yKeys);\r\n}\r\n\r\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}