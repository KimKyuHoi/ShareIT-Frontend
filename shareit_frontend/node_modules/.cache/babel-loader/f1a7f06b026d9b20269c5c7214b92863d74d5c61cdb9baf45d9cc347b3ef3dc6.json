{"ast":null,"code":"import { namedEdges, resolveEdge } from './edge.mjs';\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n  let targetPoint = 0;\n  let containerPoint = 0;\n  if (typeof offset === \"number\") {\n    /**\r\n     * If we're provided offset: [0, 0.5, 1] then each number x should become\r\n     * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\r\n     * and container etc.\r\n     */\n    offsetDefinition = [offset, offset];\n  } else if (typeof offset === \"string\") {\n    offset = offset.trim();\n    if (offset.includes(\" \")) {\n      offsetDefinition = offset.split(\" \");\n    } else {\n      /**\r\n       * If we're provided a definition like \"100px\" then we want to apply\r\n       * that only to the top of the target point, leaving the container at 0.\r\n       * Whereas a named offset like \"end\" should be applied to both.\r\n       */\n      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n    }\n  }\n  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n  containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n  return targetPoint - containerPoint;\n}\nexport { resolveOffset };","map":{"version":3,"names":["namedEdges","resolveEdge","defaultOffset","resolveOffset","offset","containerLength","targetLength","targetInset","offsetDefinition","Array","isArray","targetPoint","containerPoint","trim","includes","split"],"sources":["C:/Users/pourd/OneDrive/바탕 화면/hackton/ShareIT-Frontend/shareit_frontend/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs"],"sourcesContent":["import { namedEdges, resolveEdge } from './edge.mjs';\r\n\r\nconst defaultOffset = [0, 0];\r\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\r\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\r\n    let targetPoint = 0;\r\n    let containerPoint = 0;\r\n    if (typeof offset === \"number\") {\r\n        /**\r\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\r\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\r\n         * and container etc.\r\n         */\r\n        offsetDefinition = [offset, offset];\r\n    }\r\n    else if (typeof offset === \"string\") {\r\n        offset = offset.trim();\r\n        if (offset.includes(\" \")) {\r\n            offsetDefinition = offset.split(\" \");\r\n        }\r\n        else {\r\n            /**\r\n             * If we're provided a definition like \"100px\" then we want to apply\r\n             * that only to the top of the target point, leaving the container at 0.\r\n             * Whereas a named offset like \"end\" should be applied to both.\r\n             */\r\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\r\n        }\r\n    }\r\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\r\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\r\n    return targetPoint - containerPoint;\r\n}\r\n\r\nexport { resolveOffset };\r\n"],"mappings":"AAAA,SAASA,UAAU,EAAEC,WAAW,QAAQ,YAAY;AAEpD,MAAMC,aAAa,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;AAC5B,SAASC,aAAaA,CAACC,MAAM,EAAEC,eAAe,EAAEC,YAAY,EAAEC,WAAW,EAAE;EACvE,IAAIC,gBAAgB,GAAGC,KAAK,CAACC,OAAO,CAACN,MAAM,CAAC,GAAGA,MAAM,GAAGF,aAAa;EACrE,IAAIS,WAAW,GAAG,CAAC;EACnB,IAAIC,cAAc,GAAG,CAAC;EACtB,IAAI,OAAOR,MAAM,KAAK,QAAQ,EAAE;IAC5B;AACR;AACA;AACA;AACA;IACQI,gBAAgB,GAAG,CAACJ,MAAM,EAAEA,MAAM,CAAC;EACvC,CAAC,MACI,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IACjCA,MAAM,GAAGA,MAAM,CAACS,IAAI,CAAC,CAAC;IACtB,IAAIT,MAAM,CAACU,QAAQ,CAAC,GAAG,CAAC,EAAE;MACtBN,gBAAgB,GAAGJ,MAAM,CAACW,KAAK,CAAC,GAAG,CAAC;IACxC,CAAC,MACI;MACD;AACZ;AACA;AACA;AACA;MACYP,gBAAgB,GAAG,CAACJ,MAAM,EAAEJ,UAAU,CAACI,MAAM,CAAC,GAAGA,MAAM,GAAI,GAAE,CAAC;IAClE;EACJ;EACAO,WAAW,GAAGV,WAAW,CAACO,gBAAgB,CAAC,CAAC,CAAC,EAAEF,YAAY,EAAEC,WAAW,CAAC;EACzEK,cAAc,GAAGX,WAAW,CAACO,gBAAgB,CAAC,CAAC,CAAC,EAAEH,eAAe,CAAC;EAClE,OAAOM,WAAW,GAAGC,cAAc;AACvC;AAEA,SAAST,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}